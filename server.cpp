#include "sys/socket.h"
#include "unistd.h"
#include "stdio.h"
#include <netinet/in.h>
#include <sys/un.h>
#include <stdbool.h>
#include <cstdlib>
#include <iostream>
#include <cassert>
#include "applicationprotocol.h"
#include <vector>
#include <poll.h>

int poll(struct poll *fds, nfds_t nfds, int timeout);

static void fd_set_nonblock(int fd) {
    int flags = fcntl(fd, F_GETFL, 0);  // get the flags
    flags |= O_NONBLOCK;                // modify the flags
    fcntl(fd, F_SETFL, flags);          // set the flags
}

struct Conn{
    int fd = -1;
    // application's intention, for the event loop
    bool want_read = false;
    bool want_write = false;
    bool want_close = false;
    // buffered input and output
    std::vector<uint8_t> incoming;  // data to be parsed by th eapplication
    std::vector<uint8_t> outgoing;  // responses generated by the application
};
static Conn *handle_accept(int fd);
static Conn *handle_accept(int fd) {
    // accept
    struct sockaddr_in client_addr = {};
    socklen_t socklen = sizeof(client_addr);
    int connfd = accept(fd, (struct sockaddr *)&client_addr, &socklen);
    if (connfd < 0){
        return NULL;
    }
    // set the new connection fd to nonblocking mode
    fd_set_nb(connfd);
    // create a `struct Conn`
    Conn *conn = new Conn();
    conn->fd = connfd;
    conn->want_read = true;     // read the 1st request
    return conn;
}
static void handle_read(Conn *conn);
static void handle_read(Conn *conn) {
    // 1. Do a non-block read.
    uint8_t buf[64*1024];
    ssize_t rv = read(conn-> fd, buf, sizeof(buf));
    if (rv <= 0) {  // handle IO error 
        conn -> want_close = true;
        return;
    }

    // 2. Add new data to the `Conn::incoming` buffer.
    buf_append(conn->incoming, buf, (size_t)rv);
    // 3. Try to parse the accumulated buffer.
    // 4. Process the parsed message.
    // 5. Remove the message from `Conn::incoming`.
    try_one_request(conn)
    // ...
}

static void die(const char *msg){
    printf(msg);
    abort();
}

int main(){
    int fd = socket(AF_INET, SOCK_STREAM, 0);
    // AF_INET is for IPv4. Use AF_INET6 for IPv6 or dual-stack
    // SOCK_STREAM is for TCP. Use SOCK_DGRAM for UDP
    // 3rd is 0 
    int val = 1;
    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(val));
    // 2nd and 3rd specifies which option to set
    // the 4th argument is the option value
    // different options use different types, so the size of the option value is also needed.

    /* In this case, SO_REUSEADDR is set to and int value of 1, this option accepts a boolean value of 0 or 1. This is related to the delayed packets and TCP TIME_WAIT.
    The effect of SO_REUSEADDR is important: if it's not set to 1, a server program cannot bind to the same IP:port it was using after a restart. This is generally undesirable TCP behavior. You should enable SO_REUSEADDR for all listening sockets! 
    */

    struct sockaddr_in addr = {};
    addr.sin_family = AF_INET;
    addr.sin_port = ntohs(1234); // port
    addr.sin_addr.s_addr = ntohl(0); // wildcard IP 0.0.0.0
    int rv = bind(fd, (const struct sockaddr *)&addr, sizeof(addr)); // struct sockaddr_in holds an IPv4:port pair stored as big numbers, converted by ntohs(). For example, 1.2.3.4 is represented by ntohl(0x01020304).
    if (rv) {
        std::cerr << "bind()" << std::endl;
        exit(1);
    }
    /* All of the previous steps are just passing parameters. The socket is actually created after listen().
    The OS will automatically handle TCP handshakes and place established connections in a queue.
    The application can then retrieve them via accept().
    */

   // set the listen fd to nonblocking mode
   fd_set_nb(fd);

   // listen
    rv = listen(fd, SOMAXCONN); // second argument is the size of the queue
    if (rv) {
        std::cerr << "listen()" << std::endl;
        exit(1);
    }

    // a map of all client connections, keyed by fd
    std::vector<Conn *> fd2conn;
    // the event loop
    std::vector<struct pollfd> poll_args;
    while (true) {
        // prepare the arguments of the poll()
        poll_args.clear();
        // put the listening sockets in the first position
        struct pollfd pfd = {fd, POLLIN, 0};
        poll_args.push_back(pfd);
        // the rest are connection sockets
        for (Conn *conn : fd2conn) {
            if (!conn){
                continue;
            }
            struct pollfd pfd = {conn -> fd, POLLERR, 0};
            // poll() flags from the application's intent
            if (conn -> want_read) {
                pfd.events |= POLLIN;
            }
            if (conn -> want_write) {
                pfd.events |= POLLOUT;
            }
            poll_args.push_back(pfd);
        }

        // wait for readiness
        int rv = poll(poll_args.data(), (nfds_t)poll_args.size(), -1);
        if (rv < 0 && errno == EINTR) {
            continue;   // not an error
        }
        if (rv < 0){
            die("poll");
        }

        // handle the listening socket
        if (poll_args[0].revents) {
            if (Conn *conn = handle_accept(fd)) {
                // put it into the map
                if (fd2conn.size() <= (size_t)conn->fd) {
                    fd2conn.resize(conn -> fd + 1);
                }
                fd2conn[conn->fd] = conn;
            }
        }

        // handle connection sockets
        for (size_t i = 1; i < poll_args.size(); i++) { // skipping the first
            uint32_t ready = poll_args[i].revents;
            Conn *conn = fd2conn[poll_args[i].fd];
            if (ready & POLLIN) {   // bitwise AND
                handle_read(conn);  // application logic
            }
            if (ready & POLLOUT) {
                handle_write(conn); // application logic
            }

            // close the socket from socket error or application logic
            if ( (ready & POLLERR) || conn->want_close) {
                (void)close(conn->fd);
                fd2conn[conn->fd] = NULL;
                delete conn;
            }
        }

    }
    while (true) {
        // accept
        struct sockaddr_in client_addr = {};
        socklen_t addrlen = sizeof(client_addr);
        int connfd = accept(fd, (struct sockaddr *)&client_addr, &addrlen); // accept the connection
        if (connfd < 0){
            continue; // error
        }

        // only serves one client connection at once
        while(true) {
            int32_t err = one_request(connfd);
            if (err) {
                break;
            }
        }
        //do_something(connfd);
        close(connfd);
    }
}

// static void do_something(int connfd) {
//     char rbuf[64] = {};
//     ssize_t n = read(connfd, rbuf, sizeof(rbuf) - 1); // connection socket size

//     if (n<0){
//         std::cerr << "read() error" << std::endl;
//         return;
//     }
//     printf("client says: %s\n", rbuf);

//     std::cout << "Respond: ";
//     char wbuf[] = {}; // respond 
//     std::cin >> wbuf;
//     write(connfd, wbuf, strlen(wbuf));

//     // can replace read/write with send/recv
// }

